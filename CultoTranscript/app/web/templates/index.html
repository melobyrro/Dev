{% extends "base.html" %}

{% block title %}Dashboard - CultoTranscript{% endblock %}

{% block mobile_title %}Dashboard{% endblock %}

{% block extra_css %}
<style>
/* === CHANNEL HEADER === */
.channel-header-banner {
    background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
    margin: -1.5rem -1.5rem 2rem -1.5rem;
    padding: 2rem;
    border-radius: 0 0 12px 12px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

[data-theme="dark"] .channel-header-banner {
    background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
}

.channel-header-main {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 2rem;
    flex-wrap: wrap;
}

.channel-info {
    flex: 1;
    min-width: 300px;
}

.channel-name {
    font-size: 2rem;
    font-weight: 700;
    color: #60a5fa;
    margin: 0 0 0.5rem 0;
    line-height: 1.2;
}

.channel-url-link {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    color: #94a3b8;
    text-decoration: none;
    font-size: 0.9rem;
    transition: color 0.2s;
    word-break: break-all;
}

.channel-url-link:hover {
    color: #60a5fa;
}

.channel-url-link svg {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
}

.channel-stats-grid {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(255, 255, 255, 0.05);
    padding: 0.5rem 1rem;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.stat-icon {
    font-size: 1.2rem;
}

.stat-label {
    color: #e2e8f0;
    font-size: 0.9rem;
    white-space: nowrap;
}

/* Responsive */
@media (max-width: 768px) {
    .channel-header-main {
        flex-direction: column;
        align-items: flex-start;
    }

    .channel-stats-grid {
        width: 100%;
        flex-direction: column;
        gap: 0.75rem;
    }

    .stat-item {
        width: 100%;
    }

    .channel-name {
        font-size: 1.5rem;
    }
}

/* === DATE GROUP === */
.date-group {
    margin-bottom: 1.5rem;
    background: var(--surface);
    border: 1px solid var(--border);
    box-shadow: 0 1px 3px var(--shadow);
    border-radius: 12px;
    overflow: hidden;
}

.date-header {
    background: var(--muted);
    border-bottom: 1px solid var(--border);
    color: var(--text);
    padding: 0.75rem 1rem;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    user-select: none;
    transition: background 0.2s ease;
}

.date-header:hover {
    background: var(--muted);
    filter: brightness(0.95);
}

.date-header .arrow {
    transition: transform 0.3s;
    color: var(--text-muted);
}

.date-header.collapsed .arrow {
    transform: rotate(-90deg);
}
.date-content {
    max-height: none;
    overflow: visible;
    transition: max-height 0.3s ease;
}
.date-content.collapsed {
    max-height: 0;
    overflow: hidden;
}
.month-controls {
    padding: 0.75rem 1rem;
    background: transparent;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
}

.month-controls button {
    padding: 0.3rem 0.6rem;
    font-size: 0.85rem;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    color: var(--text-muted);
}

.month-controls button:hover {
    background: var(--muted);
    filter: brightness(0.95);
    color: var(--text);
}

@media (max-width: 768px) {
    .month-controls {
        flex-direction: column;
        align-items: stretch;
        gap: 0.35rem;
    }

    .month-controls button {
        width: 100%;
        text-align: center;
    }
}
.progress-indicator {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid #f39c12;
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 0.5rem;
    vertical-align: middle;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}
/* Progress tracking styles */
.progress-tracker {
    margin-top: 1.5rem;
    padding: 1.5rem;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: 0 1px 3px var(--shadow);
}

.progress-step {
    display: flex;
    align-items: center;
    margin-bottom: 1rem;
    padding: 0.75rem;
    background: var(--muted);
    border-radius: 8px;
    border: 1px solid var(--border);
}
.step-icon {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 1rem;
    font-size: 16px;
    flex-shrink: 0;
}
.step-icon.pending {
    background: var(--muted);
    color: var(--text-muted);
}
.step-icon.running {
    background: #D97706;
    color: white;
    animation: pulse 1.5s ease-in-out infinite;
}
.step-icon.completed {
    background: #10b981;
    color: white;
}
.step-icon.failed {
    background: #B91C1C;
    color: white;
}
@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}
.step-content {
    flex: 1;
}
.step-name {
    font-weight: bold;
    margin-bottom: 0.25rem;
}
.step-estimate {
    font-size: 0.85rem;
    color: var(--text-muted);
}
.progress-bar-container {
    width: 100%;
    height: 8px;
    background: var(--muted);
    border-radius: 4px;
    overflow: hidden;
    margin-top: 0.5rem;
}
.progress-bar {
    height: 100%;
    background: #3498db;
    transition: width 0.3s ease;
}
.progress-bar.completed {
    background: #2ecc71;
}

/* Transcript expansion styles */
.video-row {
    cursor: pointer;
    transition: background-color 0.2s;
}
.video-row:hover {
    background-color: var(--muted);
}
.video-row.expanded {
    background-color: var(--muted);
    filter: brightness(0.95);
}
.transcript-expansion {
    display: none;
    background: var(--muted);
    border-left: 4px solid var(--primary);
}
.transcript-expansion.visible {
    display: table-row;
}
.transcript-content {
    padding: 1.5rem;
    max-height: min(60vh, 800px);
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    font-family: 'Georgia', 'Times New Roman', serif;
    line-height: 1.8;
    color: var(--text);
    text-align: justify;
    overflow-wrap: anywhere;
}
@media (max-width: 768px) {
    .transcript-expansion.visible,
    .transcript-expansion.visible td {
        display: block;
        width: 100%;
    }

    .transcript-expansion.visible td {
        padding: 0;
    }

    .sermon-expansion-content {
        padding: 1.25rem 1rem;
    }

    .sermon-summary {
        font-size: 1rem;
    }

    .transcript-content {
        max-height: none;
        overflow: visible;
    }
}
.transcript-content.loading {
    text-align: center;
    color: var(--text-muted);
    font-style: italic;
}
.transcript-meta {
    padding: 0.75rem 1.5rem;
    background: var(--muted);
    border-bottom: 1px solid var(--border);
    font-size: 0.9rem;
    color: var(--text-muted);
}
.transcript-actions {
    padding: 0.75rem 1.5rem;
    background: var(--muted);
    border-top: 1px solid var(--border);
    text-align: right;
}
.expand-icon {
    display: inline-block;
    margin-right: 0.5rem;
    transition: transform 0.3s;
}
.video-row.expanded .expand-icon {
    transform: rotate(90deg);
}

/* Sermon content expansion styles */
.sermon-expansion-content {
    padding: 2rem;
    background: var(--muted);
}
.sermon-section {
    margin-bottom: 2rem;
    padding-bottom: 2rem;
    border-bottom: 1px solid var(--border);
}
.sermon-section:last-child {
    border-bottom: none;
}
.sermon-section h3 {
    color: var(--text);
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
.sermon-summary {
    line-height: 1.8;
    color: var(--text);
    text-align: justify;
    font-family: 'Georgia', 'Times New Roman', serif;
    font-size: 1.05rem;
    overflow-wrap: anywhere;
}
.sermon-summary p {
    margin-bottom: 1rem;
}
.sermon-meta {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}
.meta-card {
    background: var(--surface);
    padding: 1rem;
    border-radius: 4px;
    border-left: 3px solid var(--primary);
}
.meta-card strong {
    display: block;
    color: var(--text-muted);
    font-size: 0.85rem;
    margin-bottom: 0.25rem;
}
.meta-card span {
    font-size: 1.25rem;
    font-weight: bold;
    color: var(--text);
}
.theme-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}
.theme-tag {
    background: var(--muted);
    color: var(--primary);
    padding: 0.4rem 0.8rem;
    border-radius: 20px;
    font-size: 0.9rem;
    border: 1px solid var(--border);
}

/* Biblical References Styling */
.biblical-references {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
}

.bible-ref {
    display: inline-block;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 0.9em;
    font-weight: 500;
    color: white;
    cursor: help;
    transition: transform 0.2s, box-shadow 0.2s;
}

.bible-ref:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* Citation - solid border, darker background (explicit verse references) */
.bible-ref-citation {
    background: #2563eb; /* Blue for citations */
    border: 2px solid #1d4ed8;
}

@media (prefers-color-scheme: dark) {
    .bible-ref-citation {
        background: #3b82f6;
        border: 2px solid #60a5fa;
    }
}

/* Reading - dashed border, medium background (quoted scripture passages) */
.bible-ref-reading {
    background: #059669; /* Green for readings */
    border: 2px dashed #047857;
}

@media (prefers-color-scheme: dark) {
    .bible-ref-reading {
        background: #10b981;
        border: 2px dashed #34d399;
    }
}

/* Mention - dotted border, lighter background (biblical characters/books) */
.bible-ref-mention {
    background: #d97706; /* Orange/amber for mentions */
    border: 2px dotted #b45309;
}

@media (prefers-color-scheme: dark) {
    .bible-ref-mention {
        background: #f59e0b;
        border: 2px dotted #fbbf24;
    }
}
.highlight-item, .question-item {
    background: var(--surface);
    padding: 1rem;
    margin-bottom: 0.75rem;
    border-radius: 4px;
    border-left: 3px solid var(--accent);
}
.section-arrow {
    display: inline-block;
    width: 1em;
    text-align: center;
    transition: transform 0.2s;
}
.collapsible-section {
    overflow: hidden;
    transition: max-height 0.3s ease-out;
}
.highlight-item h4 {
    color: var(--text);
    margin-bottom: 0.5rem;
    font-size: 1rem;
}
.highlight-item p {
    color: var(--text);
    margin-bottom: 0.5rem;
    line-height: 1.6;
}
.highlight-timestamp {
    font-size: 0.85rem;
    color: var(--text-muted);
    font-family: monospace;
}
.book-list {
    list-style: none;
    padding: 0;
}
.book-list li {
    padding: 0.5rem;
    background: var(--surface);
    margin-bottom: 0.5rem;
    border-radius: 4px;
    display: flex;
    justify-content: space-between;
}
.book-list li strong {
    color: var(--text);
}
.book-list li span {
    color: var(--text-muted);
    font-size: 0.9rem;
}
.book-list-compact {
    column-count: 2;
    column-gap: 1rem;
}
.book-list-compact li {
    padding: 0.35rem 0.5rem;
    margin-bottom: 0.35rem;
    font-size: 0.85rem;
    break-inside: avoid;
}
.book-list-compact li strong {
    font-size: 0.85rem;
}
.no-data {
    color: var(--text-tertiary);
    font-style: italic;
    text-align: center;
    padding: 2rem;
}

/* === CHATBOT FAB (Floating Action Button) === */
.chat-fab {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    width: 64px;
    height: 64px;
    background: var(--primary);
    border-radius: 50%;
    box-shadow: 0 8px 24px var(--shadow);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1001;
    border: none;
}

.chat-fab:hover {
    transform: scale(1.1);
    box-shadow: 0 12px 32px var(--shadow);
}

/* === CHAT BACKDROP === */
.chat-backdrop {
    position: fixed;
    inset: 0;
    background: var(--shadow);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 999;
}

.chat-backdrop.visible {
    opacity: 1;
    pointer-events: all;
}

/* === CHATBOT DRAWER PANEL === */
.chatbot-panel {
    position: fixed;
    right: -400px;
    top: 0;
    width: 400px;
    min-width: 300px;
    max-width: 800px;
    height: 100vh;
    background: var(--surface);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    z-index: 1000;
    box-shadow: -8px 0 32px var(--shadow);
    transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.chatbot-panel.visible {
    right: 0;
}

/* Disable transition during resize for smooth dragging */
.chatbot-panel.resizing {
    transition: none;
}

/* Resize handle on the left edge */
.chatbot-resize-handle {
    position: absolute;
    left: 0;
    top: 0;
    width: 6px;
    height: 100%;
    cursor: ew-resize;
    background: transparent;
    z-index: 1001;
    transition: background 0.2s;
}

.chatbot-resize-handle:hover,
.chatbot-resize-handle.active {
    background: var(--primary);
    opacity: 0.5;
}

/* Visual indicator for resize handle */
.chatbot-resize-handle::after {
    content: '';
    position: absolute;
    left: 2px;
    top: 50%;
    transform: translateY(-50%);
    width: 2px;
    height: 40px;
    background: var(--border);
    border-radius: 1px;
    opacity: 0;
    transition: opacity 0.2s;
}

.chatbot-resize-handle:hover::after {
    opacity: 1;
}

@media (max-width: 768px) {
    .chatbot-panel {
        width: min(420px, 100%);
        right: -420px;
        min-width: unset;
        max-width: unset;
    }

    .chatbot-panel.visible {
        right: 0;
    }

    /* Hide floating chat button on mobile - use bottom nav instead */
    .chat-fab {
        display: none;
    }

    /* Hide resize handle on mobile */
    .chatbot-resize-handle {
        display: none;
    }
}

@media (max-width: 640px) {
    .chatbot-panel {
        width: 100%;
        right: -100%;
    }

    .chatbot-panel.visible {
        right: 0;
    }
}

.chatbot-header {
    background: var(--muted);
    border-bottom: 1px solid var(--border);
    color: var(--text);
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.chatbot-header h3 {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 600;
}

.chatbot-header div {
    display: flex;
    gap: 0.5rem;
}

.chatbot-close,
.chatbot-refresh {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 0.4rem 0.8rem;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.2s ease;
}

.chatbot-close:hover,
.chatbot-refresh:hover {
    background: var(--muted);
    filter: brightness(0.95);
}
.chatbot-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    background: transparent;
}
.chat-message {
    margin-bottom: 1rem;
    animation: fadeIn 0.3s;
}
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
.chat-message.user {
    text-align: right;
}
.chat-bubble {
    display: inline-block;
    padding: 0.75rem 1rem;
    border-radius: 12px;
    max-width: 80%;
    word-wrap: break-word;
}
.chat-message.user .chat-bubble {
    background: var(--primary);
    color: white;
    box-shadow: 0 2px 8px var(--shadow);
}
.chat-message.assistant .chat-bubble {
    background: var(--muted);
    color: var(--text);
    border: 1px solid var(--border);
    text-align: left;
}
.chat-citations {
    margin-top: 0.5rem;
    font-size: 0.85rem;
    color: var(--text-muted);
}
.chat-citation {
    display: inline-block;
    background: var(--muted);
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    margin-right: 0.25rem;
    margin-top: 0.25rem;
    color: var(--primary);
    border: 1px solid var(--border);
}
.chatbot-input-area {
    padding: 1rem;
    border-top: 1px solid var(--border);
    background: var(--muted);
}
.chatbot-input-area textarea {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--border);
    border-radius: 8px;
    resize: none;
    font-family: Arial, sans-serif;
    font-size: 0.95rem;
    background: var(--surface);
    color: var(--text);
    transition: all 0.2s ease;
}
.chatbot-input-area textarea:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 2px var(--shadow);
}
.chatbot-input-area textarea::placeholder {
    color: var(--text-tertiary);
}
.chatbot-input-area button {
    width: 100%;
    margin-top: 0.5rem;
    padding: 0.75rem;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px var(--shadow);
}
.chatbot-input-area button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px var(--shadow);
}
.chatbot-input-area button:disabled {
    background: var(--muted);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
    color: var(--text-tertiary);
}
.chat-loading {
    text-align: center;
    color: var(--text-muted);
    font-style: italic;
    padding: 0.5rem;
}
.chatbot-input-hint {
    margin-top: 0.35rem;
    font-size: 0.8rem;
    color: var(--text-tertiary);
    text-align: right;
}

/* Pulsing animation for processing status */
@keyframes pulse-processing {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

.status-processing {
    animation: pulse-processing 2s ease-in-out infinite;
}

/* === SUGGESTED TITLE SECTION === */
.suggested-title-section {
    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
    padding: 1rem;
    border-radius: 8px;
    border-left: 4px solid #0ea5e9;
}

[data-theme="dark"] .suggested-title-section {
    background: linear-gradient(135deg, rgba(14, 165, 233, 0.15) 0%, rgba(56, 189, 248, 0.1) 100%);
}

.suggested-title-section h3 {
    margin: 0 0 0.5rem 0;
    font-size: 0.9rem;
    color: #0369a1;
}

[data-theme="dark"] .suggested-title-section h3 {
    color: #7dd3fc;
}

.suggested-title-section p {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 600;
    color: #0c4a6e;
}

[data-theme="dark"] .suggested-title-section p {
    color: #e0f2fe;
}

.status-cell {
    min-width: 180px;
}

.status-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.15rem 0.65rem;
    border-radius: 999px;
    font-weight: 600;
    font-size: 0.9rem;
}

.status-badge.status-completed {
    background: #dcfce7;
    color: #166534;
}

.status-badge.status-processing,
.status-badge.status-queued {
    background: #fef3c7;
    color: #92400e;
}

.status-badge.status-failed,
.status-badge.status-processing_failed {
    background: #fee2e2;
    color: #991b1b;
}

.status-badge.status-too_long,
.status-badge.status-too_short {
    background: #e0f2fe;
    color: #075985;
}

[data-theme="dark"] .status-badge.status-completed {
    background: rgba(22, 101, 52, 0.25);
    color: #bbf7d0;
}

[data-theme="dark"] .status-badge.status-processing,
[data-theme="dark"] .status-badge.status-queued {
    background: rgba(234, 179, 8, 0.2);
    color: #fcd34d;
}

[data-theme="dark"] .status-badge.status-failed,
[data-theme="dark"] .status-badge.status-processing_failed {
    background: rgba(239, 68, 68, 0.2);
    color: #fecaca;
}

[data-theme="dark"] .status-badge.status-too_long,
[data-theme="dark"] .status-badge.status-too_short {
    background: rgba(14, 165, 233, 0.2);
    color: #bae6fd;
}

.status-subtext {
    margin-top: 0.35rem;
    font-size: 0.85rem;
    color: var(--text-muted);
}

.status-error-text {
    margin-top: 0.5rem;
    font-size: 0.85rem;
    color: #b91c1c;
    font-family: monospace;
    white-space: pre-wrap;
    word-break: break-word;
}
</style>
{% endblock %}

{% block content %}

<!-- Chatbot FAB (Floating Action Button) -->
{% if channel %}
<button id="chatFAB" class="chat-fab" onclick="toggleChatDrawer()" title="Abrir Assistente IA">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width: 28px; height: 28px;">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
    </svg>
</button>

<!-- Chat Backdrop -->
<div id="chatBackdrop" class="chat-backdrop" onclick="toggleChatDrawer()"></div>

<!-- Chatbot Drawer -->
<div class="chatbot-panel" id="chatbotPanel">
    <!-- Resize handle for desktop -->
    <div class="chatbot-resize-handle" id="chatbotResizeHandle"></div>
    <div class="chatbot-header">
        <h3>ü§ñ Assistente IA</h3>
        <div>
            <button class="chatbot-close" onclick="toggleChatDrawer()" title="Fechar">‚úï</button>
            <button class="chatbot-refresh" onclick="refreshChat()" title="Limpar">üîÑ</button>
        </div>
    </div>
    <div class="chatbot-messages" id="chatMessages">
        <div class="chat-message assistant">
            <div class="chat-bubble">
                Ol√°! Sou seu assistente para explorar os serm√µes. Posso responder perguntas sobre qualquer prega√ß√£o, temas b√≠blicos ou conte√∫do espec√≠fico. Como posso ajudar?
            </div>
        </div>
    </div>
    <div class="chatbot-input-area">
        <textarea id="chatInput"
                  rows="3"
                  placeholder="Digite sua pergunta sobre os serm√µes..."
                  onkeydown="if(event.key==='Enter' && !event.shiftKey){event.preventDefault();sendChatMessage();}"></textarea>
        <button id="chatSendBtn" onclick="sendChatMessage()">Enviar</button>
        <div class="chatbot-input-hint">Use Shift + Enter para adicionar uma nova linha</div>
    </div>
</div>
{% endif %}

<!-- Channel Header -->
{% if channel %}
<div class="card channel-header-banner">
    <div class="channel-header-main">
        <!-- Left side: Channel name and URL -->
        <div class="channel-info">
            <h1 class="channel-name">{{ channel.title }}</h1>
            <a href="{{ channel.youtube_url }}"
               target="_blank"
               class="channel-url-link"
               rel="noopener noreferrer">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                </svg>
                {{ channel.youtube_url }}
            </a>
        </div>

        <!-- Right side: Stats -->
        <div class="channel-stats-grid">
            <div class="stat-item">
                <span class="stat-icon">üìä</span>
                <span class="stat-label">{{ total_videos }} v√≠deos</span>
            </div>
            <div class="stat-item">
                <span class="stat-icon">‚úÖ</span>
                <span class="stat-label">{{ completed_videos }} processados</span>
            </div>
            {% if channel.last_checked_at %}
            <div class="stat-item">
                <span class="stat-icon">üïê</span>
                <span class="stat-label">√öltima verifica√ß√£o: {{ channel.last_checked_at.strftime('%m/%d/%Y') }}</span>
            </div>
            {% endif %}
        </div>
    </div>
</div>
{% else %}
<div class="card">
    <h2>üì∫ CultoTranscript</h2>
    <p class="text-secondary">Nenhum canal configurado ainda. Aguardando configura√ß√£o...</p>
</div>
{% endif %}


<!-- Recent Videos -->
{% if channel %}
<div class="card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h2 style="margin: 0;">V√≠deos Recentes</h2>
        <div id="groupControls" style="display: none;">
            <button onclick="expandAllGroups()" class="btn btn-secondary" style="padding: 0.4rem 0.8rem; font-size: 0.9rem; margin-right: 0.5rem;">
                ‚ñº Expandir Todos
            </button>
            <button onclick="collapseAllGroups()" class="btn btn-secondary" style="padding: 0.4rem 0.8rem; font-size: 0.9rem;">
                ‚ñ≤ Recolher Todos
            </button>
        </div>
    </div>
    <div id="recentVideos">Carregando...</div>
</div>
{% endif %}
{% endblock %}

{% block extra_js %}
<script>
const CHANNEL_ID = {{ channel.id if channel else 'null' }};
let csrfToken = null;
let isLoadingVideos = false;
let processingRefreshTimer = null;

const STATUS_ICONS = {
    completed: '‚úÖ',
    processing: '‚è≥',
    queued: 'üìã',
    failed: '‚ùå',
    processing_failed: '‚ùå',
    pending: '‚è∏Ô∏è',
    too_long: '‚è±Ô∏è',
    too_short: '‚è±Ô∏è',
    unknown: '‚ùì'
};

const STATUS_LABELS = {
    completed: 'Conclu√≠do',
    processing: 'Processando',
    queued: 'Na fila',
    failed: 'Falhou',
    processing_failed: 'Falhou',
    pending: 'Pendente',
    too_long: 'Muito longo',
    too_short: 'Muito curto',
    unknown: 'Desconhecido'
};

// Refresh CSRF token from server
async function refreshCSRFToken() {
    try {
        const response = await fetch(`/api/videos?limit=1`);
        const newToken = response.headers.get('X-CSRF-Token');
        if (newToken) {
            csrfToken = newToken;
            return true;
        }
        console.warn('No CSRF token in response headers');
        return false;
    } catch (error) {
        console.error('Failed to refresh CSRF token:', error);
        return false;
    }
}

// Load recent videos with date grouping
async function loadRecentVideos() {
    if (!CHANNEL_ID || isLoadingVideos) return;
    isLoadingVideos = true;

    // Store currently expanded video IDs BEFORE rebuilding
    const expandedIds = Array.from(document.querySelectorAll('.video-row.expanded'))
        .map(row => parseInt(row.getAttribute('data-video-id')));

    try {
        const response = await fetch(`/api/channels/${CHANNEL_ID}/videos?limit=50`);
        csrfToken = response.headers.get('X-CSRF-Token');
        const data = await response.json();

        const container = document.getElementById('recentVideos');

        if (data.videos && data.videos.length > 0) {
            // Group videos by date
            const grouped = groupVideosByDate(data.videos);

            let html = '';
            for (const [dateKey, videos] of Object.entries(grouped)) {
                html += `
                    <div class="date-group" id="group-${dateKey}">
                        <div class="date-header" onclick="toggleDateGroup(this)">
                            <span>${formatDateHeader(dateKey)}</span>
                            <span class="arrow">‚ñº</span>
                        </div>
                        <div class="date-content">
                            <div class="month-controls">
                                <button onclick="expandAllVideosInMonth('${dateKey}')">‚ñº Expandir Todos</button>
                                <button onclick="collapseAllVideosInMonth('${dateKey}')">‚ñ≤ Recolher Todos</button>
                            </div>
                            <!-- Desktop Table View -->
                            <div class="table-wrapper">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>T√≠tulo</th>
                                            <th>Status</th>
                                            <th>Dura√ß√£o</th>
                                            <th>A√ß√µes</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${videos.map(v => `
                                            <tr class="video-row" data-video-id="${v.id}" onclick="toggleTranscript(${v.id}, this)">
                                                <td>
                                                    <span class="expand-icon">‚ñ∂</span>
                                                    ${formatVideoTitle(v)}
                                            </td>
                                            <td class="status-cell">${renderStatusCell(v)}</td>
                                            <td>${formatDuration(v.duration_sec)}</td>
                                            <td onclick="event.stopPropagation();">
                                                <button onclick="reprocessVideo(${v.id}, '${v.title.replace(/'/g, "\\'")}')"
                                                        class="btn"
                                                        style="padding: 0.3rem 0.6rem; font-size: 0.85rem; background: #f39c12;">
                                                    Reprocessar
                                                </button>
                                                <button onclick="excludeVideo(${v.id}, '${v.title.replace(/'/g, "\\'")}')"
                                                        class="btn btn-secondary"
                                                        style="padding: 0.3rem 0.6rem; font-size: 0.85rem; margin-left: 0.3rem; background: #dc3545;">
                                                    Excluir
                                                </button>
                                            </td>
                                        </tr>
                                        <tr class="transcript-expansion" id="transcript-${v.id}">
                                            <td colspan="4">
                                                <div class="transcript-loading" style="padding: 2rem; text-align: center; display: none;">
                                                    <span class="progress-indicator"></span> Carregando transcri√ß√£o...
                                                </div>
                                                <div class="transcript-container" style="display: none;"></div>
                                            </td>
                                        </tr>
                                    `).join('')}
                                    </tbody>
                                </table>
                            </div>
                            <!-- Mobile Cards View -->
                            <div class="mobile-cards-view">
                                ${videos.map(v => renderMobileCard(v)).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            stopAllPolling();
            container.innerHTML = html;

            // Show group controls if there are videos
            const groupControls = document.getElementById('groupControls');
            if (groupControls) {
                groupControls.style.display = 'block';
            }

            // Restore expansion states for previously expanded videos
            for (const videoId of expandedIds) {
                const row = document.querySelector(`.video-row[data-video-id="${videoId}"]`);
                if (row && !row.classList.contains('expanded')) {
                    await toggleTranscript(videoId, row);
                }
            }

            let hasActiveJobs = false;
            data.videos.forEach(video => {
                initializeVideoStatus(video);
                if (shouldTrackJob(video)) {
                    hasActiveJobs = true;
                }
            });

            scheduleProcessingRefresh(hasActiveJobs);
        } else {
            stopAllPolling();
            container.innerHTML = '<p class="no-data">Nenhum v√≠deo encontrado.</p>';

            // Hide group controls if no videos
            const groupControls = document.getElementById('groupControls');
            if (groupControls) {
                groupControls.style.display = 'none';
            }
            scheduleProcessingRefresh(false);
        }
    } catch (error) {
        document.getElementById('recentVideos').innerHTML = '<p class="no-data">Erro ao carregar v√≠deos.</p>';

        // Hide group controls on error
        const groupControls = document.getElementById('groupControls');
        if (groupControls) {
            groupControls.style.display = 'none';
        }
        scheduleProcessingRefresh(false);
    } finally {
        isLoadingVideos = false;
    }
}

function parseDateParts(dateStr) {
    if (!dateStr) {
        return null;
    }

    const normalized = dateStr.replace('T', ' ');
    const parts = normalized.split(' ')[0].split('-');
    if (parts.length !== 3) {
        return null;
    }

    const [year, month, day] = parts.map(part => parseInt(part, 10));
    if (Number.isNaN(year) || Number.isNaN(month) || Number.isNaN(day)) {
        return null;
    }

    return { year, month, day };
}

function extractDisplayDateParts(video) {
    const dateStr = video.sermon_actual_date || video.published_at || video.video_created_at;
    if (!dateStr) {
        return null;
    }

    const normalized = dateStr.split('T')[0];
    const [yearStr, monthStr, dayStr] = normalized.split('-');
    const year = parseInt(yearStr, 10);
    const month = parseInt(monthStr, 10);
    const day = parseInt(dayStr, 10);

    if (Number.isNaN(year) || Number.isNaN(month) || Number.isNaN(day)) {
        return null;
    }

    return {
        year,
        month,
        day,
        key: `${year}-${String(month).padStart(2, '0')}`,
        timestamp: Date.UTC(year, month - 1, day)
    };
}

// Group videos by year and month using video_created_at (with fallback to published_at)
function groupVideosByDate(videos) {
    const grouped = {};

    videos.forEach(video => {
        const info = extractDisplayDateParts(video);
        if (!info) {
            return;
        }
        const key = info.key;

        if (!grouped[key]) {
            grouped[key] = [];
        }
        grouped[key].push(video);
    });

    // Sort videos within each group by date descending
    Object.keys(grouped).forEach(key => {
        grouped[key].sort((a, b) => {
            const infoA = extractDisplayDateParts(a);
            const infoB = extractDisplayDateParts(b);
            return (infoB?.timestamp || 0) - (infoA?.timestamp || 0);
        });
    });

    return grouped;
}

// Format video title with video creation date prefix (mm/dd/yyyy format)
function formatVideoTitle(video) {
    // Title already includes date prefix from database
    let html = escapeHtml(video.title);

    // Show AI suggested title if available
    if (video.suggested_title) {
        html += `
            <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
                <span style="background: #0ea5e9; color: white; padding: 0.1rem 0.35rem; border-radius: 3px; font-size: 0.7rem; font-weight: 600;">IA</span>
                ${escapeHtml(video.suggested_title)}
            </div>
        `;
    }

    return html;
}

// Format date header for monthly groups
function formatDateHeader(dateKey) {
    const [year, month] = dateKey.split('-');
    const monthIndex = parseInt(month) - 1;

    const monthNames = ['Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho',
                        'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];

    const today = new Date();
    const currentYear = today.getFullYear();
    const currentMonth = today.getMonth();

    // Check if this is the current month
    if (parseInt(year) === currentYear && monthIndex === currentMonth) {
        return `${monthNames[monthIndex]} de ${year} (M√™s Atual)`;
    }

    return `${monthNames[monthIndex]} de ${year}`;
}

function normalizeStatus(status) {
    if (!status) return 'unknown';
    if (status === 'processing_failed') return 'failed';
    return status;
}

function escapeHtml(str) {
    if (!str && str !== 0) return '';
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function truncateText(str, maxLength = 140) {
    if (!str || str.length <= maxLength) return str;
    return `${str.substring(0, maxLength - 1)}‚Ä¶`;
}

function renderStatusCell(video) {
    const status = normalizeStatus(video.status);
    const icon = STATUS_ICONS[status] || STATUS_ICONS.unknown;
    const label = STATUS_LABELS[status] || STATUS_LABELS.unknown;
    const job = video.current_job || null;

    let html = `<div class="status-badge status-${status}">${icon} <span>${label}</span></div>`;

    if (job && ['queued', 'running'].includes(job.status)) {
        const message = job.metadata?.step_message || 'Processando...';
        html += `<div class="status-subtext">${escapeHtml(message)}</div>`;
    } else if ((job && job.status === 'failed') || status === 'failed') {
        const reason = job?.error || video.error_message;
        if (reason) {
            html += `<div class="status-error-text">${escapeHtml(truncateText(reason))}</div>`;
        }
    } else if (video.error_message && status === 'too_long') {
        html += `<div class="status-error-text">${escapeHtml(truncateText(video.error_message))}</div>`;
    }

    return html;
}

// Render mobile card for a video
function renderMobileCard(video) {
    const status = normalizeStatus(video.status);
    const icon = STATUS_ICONS[status] || STATUS_ICONS.unknown;
    const label = STATUS_LABELS[status] || STATUS_LABELS.unknown;
    const job = video.current_job || null;
    const escapedTitle = video.title.replace(/'/g, "\\'");

    // Get speaker if available
    const speaker = video.speaker_name || video.default_speaker || '';

    // Format date
    const dateInfo = extractDisplayDateParts(video);
    const dateDisplay = dateInfo ? `${String(dateInfo.month).padStart(2, '0')}/${String(dateInfo.day).padStart(2, '0')}/${dateInfo.year}` : '';

    let statusHtml = `<div class="status-badge status-${status}">${icon} <span>${label}</span></div>`;

    // Add processing message or error
    let extraInfo = '';
    if (job && ['queued', 'running'].includes(job.status)) {
        const message = job.metadata?.step_message || 'Processando...';
        extraInfo = `<div class="status-subtext" style="font-size: 0.75rem; margin-top: 0.25rem;">${escapeHtml(message)}</div>`;
    } else if ((job && job.status === 'failed') || status === 'failed') {
        const reason = job?.error || video.error_message;
        if (reason) {
            extraInfo = `<div class="status-error-text" style="font-size: 0.75rem; margin-top: 0.25rem;">${escapeHtml(truncateText(reason, 80))}</div>`;
        }
    }

    return `
        <div class="sermon-card" data-video-id="${video.id}" onclick="toggleMobileCardExpansion(this, ${video.id})">
            <div class="sermon-card-header">
                <h3 class="sermon-card-title">${escapeHtml(video.title)}</h3>
                ${video.suggested_title ? `
                <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
                    <span style="background: #0ea5e9; color: white; padding: 0.1rem 0.35rem; border-radius: 3px; font-size: 0.7rem; font-weight: 600;">IA</span>
                    ${escapeHtml(video.suggested_title)}
                </div>
                ` : ''}
                <div class="sermon-card-status">
                    ${statusHtml}
                </div>
            </div>
            <div class="sermon-card-meta">
                ${speaker ? `
                <div class="sermon-card-meta-item">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                    </svg>
                    <span>${escapeHtml(speaker)}</span>
                </div>
                ` : ''}
                ${dateDisplay ? `
                <div class="sermon-card-meta-item">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    <span>${dateDisplay}</span>
                </div>
                ` : ''}
                <div class="sermon-card-meta-item">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>${formatDuration(video.duration_sec)}</span>
                </div>
            </div>
            ${extraInfo}
            <div class="sermon-card-content" id="mobile-content-${video.id}">
                <div class="transcript-loading" style="padding: 1rem; text-align: center; display: none;">
                    <span class="progress-indicator"></span> Carregando...
                </div>
                <div class="transcript-container" style="display: none;"></div>
            </div>
            <div class="sermon-card-actions" onclick="event.stopPropagation();">
                <button class="sermon-card-action" onclick="event.stopPropagation(); reprocessVideo(${video.id}, '${escapedTitle}')">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    Reprocessar
                </button>
                <button class="sermon-card-action danger" onclick="event.stopPropagation(); excludeVideo(${video.id}, '${escapedTitle}')">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                    Excluir
                </button>
            </div>
        </div>
    `;
}

// Toggle mobile card expansion
function toggleMobileCardExpansion(cardElement, videoId) {
    const isExpanded = cardElement.classList.contains('expanded');

    if (isExpanded) {
        cardElement.classList.remove('expanded');
    } else {
        cardElement.classList.add('expanded');

        // Load content if not already loaded
        const container = cardElement.querySelector('.transcript-container');
        const loading = cardElement.querySelector('.transcript-loading');

        if (container && !container.innerHTML) {
            // Trigger the same load as desktop
            const desktopRow = document.querySelector(`.video-row[data-video-id="${videoId}"]`);
            if (desktopRow && !desktopRow.classList.contains('expanded')) {
                toggleTranscript(videoId, desktopRow);
            }

            // Copy content from desktop version after a short delay
            setTimeout(() => {
                const desktopContainer = document.querySelector(`#transcript-${videoId} .transcript-container`);
                if (desktopContainer && desktopContainer.innerHTML) {
                    container.innerHTML = desktopContainer.innerHTML;
                    container.style.display = 'block';
                    loading.style.display = 'none';
                }
            }, 500);
        }
    }
}

function setVideoStatusBadge(videoId, status) {
    const normalized = normalizeStatus(status);
    const row = document.querySelector(`.video-row[data-video-id="${videoId}"]`);
    if (!row) return;

    const cell = row.querySelector('.status-cell');
    if (!cell) return;

    let badge = cell.querySelector('.status-badge');
    if (!badge) {
        badge = document.createElement('div');
        badge.className = 'status-badge';
        cell.prepend(badge);
    }

    badge.className = `status-badge status-${normalized}`;
    badge.innerHTML = `${STATUS_ICONS[normalized] || STATUS_ICONS.unknown} <span>${STATUS_LABELS[normalized] || STATUS_LABELS.unknown}</span>`;
}

function setVideoStatusSubtext(videoId, text) {
    const row = document.querySelector(`.video-row[data-video-id="${videoId}"]`);
    if (!row) return;
    const cell = row.querySelector('.status-cell');
    if (!cell) return;

    let subtext = cell.querySelector('.status-subtext');
    if (!subtext) {
        subtext = document.createElement('div');
        subtext.className = 'status-subtext';
        cell.appendChild(subtext);
    }

    subtext.textContent = text || 'Processando...';
}

function setVideoStatusError(videoId, message) {
    const row = document.querySelector(`.video-row[data-video-id="${videoId}"]`);
    if (!row) return;
    const cell = row.querySelector('.status-cell');
    if (!cell) return;

    let errorEl = cell.querySelector('.status-error-text');
    if (!message) {
        if (errorEl) errorEl.remove();
        return;
    }

    if (!errorEl) {
        errorEl = document.createElement('div');
        errorEl.className = 'status-error-text';
        cell.appendChild(errorEl);
    }
    errorEl.textContent = message;
}

function shouldTrackJob(video) {
    if (video.current_job && ['queued', 'running'].includes(video.current_job.status)) {
        return true;
    }
    return video.status === 'processing';
}

function initializeVideoStatus(video) {
    if (video.current_job) {
        if (['queued', 'running'].includes(video.current_job.status)) {
            setVideoStatusBadge(video.id, 'processing');
            if (video.current_job.metadata?.step_message) {
                setVideoStatusSubtext(video.id, video.current_job.metadata.step_message);
            }
            startPolling(video.current_job.id, video.id, 3000);
        } else if (video.current_job.status === 'failed') {
            setVideoStatusBadge(video.id, 'failed');
            setVideoStatusError(video.id, truncateText(video.current_job.error || video.error_message));
        }
    } else if ((video.status === 'failed' || video.status === 'processing_failed') && video.error_message) {
        setVideoStatusBadge(video.id, 'failed');
        setVideoStatusError(video.id, truncateText(video.error_message));
    } else if (video.status === 'processing') {
        setVideoStatusBadge(video.id, 'processing');
        setVideoStatusSubtext(video.id, 'Processando...');
    }
}

function scheduleProcessingRefresh(shouldSchedule) {
    if (shouldSchedule) {
        if (!processingRefreshTimer) {
            processingRefreshTimer = setInterval(() => {
                loadRecentVideos();
            }, 20000);
        }
    } else if (processingRefreshTimer) {
        clearInterval(processingRefreshTimer);
        processingRefreshTimer = null;
    }
}

// Toggle date group
function toggleDateGroup(header) {
    header.classList.toggle('collapsed');
    const content = header.nextElementSibling;
    content.classList.toggle('collapsed');
}

// Expand all monthly groups and all videos within them
function expandAllGroups() {
    const headers = document.querySelectorAll('.date-header');
    const contents = document.querySelectorAll('.date-content');

    headers.forEach(header => header.classList.remove('collapsed'));
    contents.forEach(content => content.classList.remove('collapsed'));

    // Also expand all video content
    const videoRows = document.querySelectorAll('.video-row:not(.expanded)');
    videoRows.forEach(row => {
        const videoId = row.getAttribute('data-video-id');
        if (videoId) {
            row.click();
        }
    });
}

// Collapse all monthly groups and all videos within them
function collapseAllGroups() {
    // First collapse all video content
    const videoRows = document.querySelectorAll('.video-row.expanded');
    videoRows.forEach(row => {
        const videoId = row.getAttribute('data-video-id');
        if (videoId) {
            row.click();
        }
    });

    // Then collapse the monthly groups
    const headers = document.querySelectorAll('.date-header');
    const contents = document.querySelectorAll('.date-content');

    headers.forEach(header => header.classList.add('collapsed'));
    contents.forEach(content => content.classList.add('collapsed'));
}

// Expand all videos within a specific month
function expandAllVideosInMonth(dateKey) {
    const group = document.getElementById(`group-${dateKey}`);
    if (!group) return;

    // Find all video rows in this month that are not already expanded
    const videoRows = group.querySelectorAll('.video-row:not(.expanded)');

    videoRows.forEach(row => {
        const videoId = row.getAttribute('data-video-id');
        if (videoId) {
            // Simulate click to expand
            row.click();
        }
    });
}

// Collapse all videos within a specific month
function collapseAllVideosInMonth(dateKey) {
    const group = document.getElementById(`group-${dateKey}`);
    if (!group) return;

    // Find all video rows in this month that are expanded
    const videoRows = group.querySelectorAll('.video-row.expanded');

    videoRows.forEach(row => {
        const videoId = row.getAttribute('data-video-id');
        if (videoId) {
            // Simulate click to collapse
            row.click();
        }
    });
}

// ========== JOB STATUS POLLING SYSTEM ==========

// Global polling state
const activePollingJobs = new Map(); // Map<jobId, intervalId>

// Poll job status and update UI
async function pollJobStatus(jobId, videoId) {
    try {
        const response = await fetch(`/api/jobs/${jobId}/status`);
        const data = await response.json();

        console.log(`üìä Job ${jobId} status: ${data.status}`);

        // Update UI with full metadata (step-by-step progress)
        if (data.metadata && (data.status === 'running' || data.status === 'queued')) {
            updateVideoRowProgress(videoId, data.metadata);
        }

        // Check if job completed
        if (data.status === 'completed') {
            console.log(`‚úÖ Job ${jobId} completed! Refreshing video list...`);
            stopPolling(jobId);
            await loadRecentVideos();
            showToast('Reprocessamento conclu√≠do!', 'success');
        } else if (data.status === 'failed') {
            console.log(`‚ùå Job ${jobId} failed: ${data.error || 'Unknown error'}`);
            stopPolling(jobId);

            // Show detailed error in progress UI
            showJobError(videoId, data.error || 'Erro desconhecido');

            // Also show toast
            showToast('Reprocessamento falhou. Veja detalhes abaixo.', 'error');

            // Don't refresh immediately - let user see the error
            setTimeout(() => {
                loadRecentVideos();
            }, 10000); // Refresh after 10 seconds
        }
        // Continue polling if status is 'queued' or 'running'

    } catch (error) {
        console.error(`‚ö†Ô∏è Error polling job ${jobId}:`, error);
        // Don't stop polling on network errors - will retry
    }
}

// Start polling for a job
function startPolling(jobId, videoId, intervalMs = 3000) {
    // Don't start if already polling
    if (activePollingJobs.has(jobId)) {
        console.log(`Already polling job ${jobId}`);
        return;
    }

    console.log(`üîÑ Starting polling for job ${jobId} (every ${intervalMs}ms)`);

    // Poll immediately once
    pollJobStatus(jobId, videoId);

    // Then poll at intervals
    const intervalId = setInterval(() => {
        pollJobStatus(jobId, videoId);
    }, intervalMs);

    activePollingJobs.set(jobId, intervalId);

    // Safety timeout: stop polling after 10 minutes
    setTimeout(() => {
        if (activePollingJobs.has(jobId)) {
            console.warn(`‚è±Ô∏è Job ${jobId} polling timed out after 10 minutes`);
            stopPolling(jobId);
            loadRecentVideos(); // Refresh anyway
        }
    }, 600000); // 10 minutes
}

// Stop polling for a job
function stopPolling(jobId) {
    const intervalId = activePollingJobs.get(jobId);
    if (intervalId) {
        clearInterval(intervalId);
        activePollingJobs.delete(jobId);
        console.log(`‚èπÔ∏è Stopped polling for job ${jobId}`);
    }
}

// Stop all active polling (e.g., on page unload)
function stopAllPolling() {
    activePollingJobs.forEach((intervalId, jobId) => {
        clearInterval(intervalId);
    });
    activePollingJobs.clear();
    console.log('Stopped all polling');
}

// Show detailed error when job fails
function showJobError(videoId, errorMessage) {
    console.log(`‚ùå Showing error for video ${videoId}:`, errorMessage);

    // Find the expansion row
    const expansionRow = document.getElementById(`transcript-${videoId}`);
    if (!expansionRow) {
        console.log(`No expansion row found for video ${videoId}`);
        return;
    }

    // Make sure row is expanded
    if (!expansionRow.classList.contains('show')) {
        expansionRow.classList.add('show');
    }

    // Simplify long SQL errors (extract just the main message)
    let displayError = errorMessage;
    if (errorMessage.length > 500) {
        // Try to extract the main error message
        const match = errorMessage.match(/^([^(]+)/);
        if (match) {
            displayError = match[1].trim();
        } else {
            displayError = errorMessage.substring(0, 500) + '...';
        }
    }

    setVideoStatusBadge(videoId, 'failed');
    setVideoStatusError(videoId, truncateText(displayError));

    // Inject error UI into the expansion row
    const transcriptDiv = expansionRow.querySelector('.transcript-loading');
    if (transcriptDiv) {
        transcriptDiv.style.display = 'block';
        transcriptDiv.innerHTML = `
            <div class="progress-tracker" style="border-color: #B91C1C; background: #FEE2E2;">
                <h4 style="margin-bottom: 1rem; color: #B91C1C;">‚ùå Reprocessamento falhou</h4>
                <div style="background: white; border: 1px solid #B91C1C; border-radius: 8px; padding: 1rem; margin-top: 1rem;">
                    <p style="font-weight: 600; margin-bottom: 0.5rem; color: #B91C1C;">Detalhes do erro:</p>
                    <p style="font-family: monospace; font-size: 0.9rem; color: #666; white-space: pre-wrap; word-break: break-word;">${displayError}</p>
                </div>
                <div style="margin-top: 1rem; padding: 1rem; background: #FEF3C7; border-radius: 8px; border: 1px solid #F59E0B;">
                    <p style="margin: 0; color: #92400E; font-size: 0.9rem;">
                        üí° <strong>Sugest√£o:</strong> Tente reprocessar novamente. O erro pode ter sido corrigido.
                        Se o problema persistir, entre em contato com o suporte.
                    </p>
                </div>
                <button
                    onclick="document.getElementById('transcript-${videoId}').classList.remove('show')"
                    style="margin-top: 1rem; padding: 0.5rem 1rem; background: #6B7280; color: white; border: none; border-radius: 6px; cursor: pointer;"
                >
                    Fechar
                </button>
            </div>
        `;
    }
}

// Update video row with progress display (step-by-step visual progress)
function updateVideoRowProgress(videoId, metadata) {
    console.log(`üìù Video ${videoId} progress update`, metadata);

    if (!metadata || !metadata.steps) {
        console.log(`No step metadata for video ${videoId}`);
        return;
    }

    if (metadata.step_message) {
        setVideoStatusBadge(videoId, 'processing');
        setVideoStatusSubtext(videoId, metadata.step_message);
    }

    // Find the expansion row where we'll show progress
    const expansionRow = document.getElementById(`transcript-${videoId}`);
    if (!expansionRow) {
        console.log(`No expansion row found for video ${videoId}`);
        return;
    }

    // Make sure row is expanded
    if (!expansionRow.classList.contains('show')) {
        expansionRow.classList.add('show');
    }

    // Calculate overall progress
    const currentStep = parseInt(metadata.current_step || "0");
    const totalSteps = parseInt(metadata.total_steps || 6);
    const progressPercent = Math.round((currentStep / totalSteps) * 100);

    // Build step HTML
    let stepsHTML = '';
    const stepEntries = Object.entries(metadata.steps).sort((a, b) => parseInt(a[0]) - parseInt(b[0]));

    for (const [key, step] of stepEntries) {
        const icon = {
            'pending': '‚è∏Ô∏è',
            'running': '‚è≥',
            'completed': '‚úÖ',
            'failed': '‚ùå'
        }[step.status] || '‚è∏Ô∏è';

        stepsHTML += `
            <div class="progress-step ${step.status}">
                <div class="step-icon ${step.status}">${icon}</div>
                <div class="step-content">
                    <div class="step-name">${step.name}</div>
                    ${step.estimate ? `<div class="step-estimate">${step.estimate}</div>` : ''}
                </div>
            </div>
        `;
    }

    // Calculate estimated time remaining
    let timeRemaining = '';
    if (currentStep < totalSteps) {
        const remainingSteps = stepEntries.slice(currentStep);
        let minTime = 0;
        let maxTime = 0;

        for (const [, step] of remainingSteps) {
            if (step.estimate) {
                const match = step.estimate.match(/(\d+)-?(\d*)/);
                if (match) {
                    minTime += parseInt(match[1]);
                    maxTime += parseInt(match[2] || match[1]);
                }
            }
        }

        if (minTime > 0) {
            timeRemaining = `<p style="margin-top: 1rem; color: var(--text-muted); font-size: 0.9rem;">‚è±Ô∏è Tempo estimado restante: ${minTime}${maxTime !== minTime ? `-${maxTime}` : ''}s</p>`;
        }
    }

    // Inject progress UI into the expansion row
    const transcriptDiv = expansionRow.querySelector('.transcript-loading');
    if (transcriptDiv) {
        transcriptDiv.style.display = 'block';
        transcriptDiv.innerHTML = `
            <div class="progress-tracker">
                <h4 style="margin-bottom: 1rem;">üîÑ Reprocessando v√≠deo...</h4>
                <div class="progress-bar-container">
                    <div class="progress-bar ${progressPercent === 100 ? 'completed' : ''}" style="width: ${progressPercent}%;"></div>
                </div>
                <p style="margin: 0.75rem 0; font-weight: 500;">Etapa ${currentStep} de ${totalSteps} (${progressPercent}%)</p>
                ${stepsHTML}
                ${timeRemaining}
            </div>
        `;
    }
}

// Simple toast notification
function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
        color: white;
        padding: 1rem 2rem;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 9999;
        font-size: 14px;
    `;

    document.body.appendChild(toast);

    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

// Clean up on page unload
window.addEventListener('beforeunload', stopAllPolling);

// Reprocess video function
async function reprocessVideo(videoId, title) {
    // Refresh CSRF token before operation
    if (!await refreshCSRFToken()) {
        alert('Erro: N√£o foi poss√≠vel validar a sess√£o. Por favor, recarregue a p√°gina.');
        return;
    }

    // Prompt for password
    const password = prompt(`Reprocessar v√≠deo "${title}"?\n\nEsta a√ß√£o ir√°:\n- Re-executar detec√ß√£o de in√≠cio do serm√£o\n- Regenerar an√°lise de IA e resumo\n- Atualizar todos os dados anal√≠ticos\n\nDigite a senha de admin para confirmar:`);

    if (!password) {
        return; // User cancelled
    }

    // Find the video row and expansion
    const videoRow = document.querySelector(`.video-row[data-video-id="${videoId}"]`);
    const expansionRow = document.getElementById(`transcript-${videoId}`);

    try {
        setVideoStatusBadge(videoId, 'processing');
        setVideoStatusSubtext(videoId, 'Inicializando reprocessamento...');
        setVideoStatusError(videoId, '');

        // Expand the video row to show progress (if not already expanded)
        if (videoRow && !videoRow.classList.contains('expanded')) {
            videoRow.click(); // Expand to show transcript/progress area
        }

        // Show initial processing state in expansion area
        if (expansionRow) {
            const transcriptDiv = expansionRow.querySelector('.transcript-loading');
            if (transcriptDiv) {
                transcriptDiv.style.display = 'block';
                transcriptDiv.innerHTML = `
                    <div class="progress-tracker">
                        <h4 style="margin-bottom: 1rem;">üîÑ Iniciando reprocessamento...</h4>
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: 0%;"></div>
                        </div>
                        <p style="margin: 0.75rem 0; font-weight: 500;">Aguardando in√≠cio do processamento...</p>
                    </div>
                `;
            }
        }

        const response = await fetch(`/api/videos/${videoId}/reprocess`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': csrfToken
            },
            body: JSON.stringify({ password: password })
        });

        const data = await response.json();

        if (response.ok && data.success) {
            showToast('Reprocessamento iniciado! Acompanhe o progresso abaixo.', 'info');

            // Start polling with job_id
            if (data.job_id) {
                startPolling(data.job_id, videoId, 3000); // Poll every 3 seconds
            } else {
                // Fallback: single refresh after 2 seconds (if job_id not provided)
                setTimeout(() => {
                    loadRecentVideos();
                }, 2000);
            }
        } else {
            alert(`Erro: ${data.detail || 'Falha ao iniciar reprocessamento'}`);

            // Restore row state
            if (videoRow) {
                loadRecentVideos();
            }
        }
    } catch (error) {
        alert(`Erro ao reprocessar v√≠deo: ${error.message}`);

        // Restore row state
        if (videoRow) {
            loadRecentVideos();
        }
    }
}

// Exclude video function (uses /exclude endpoint)
async function excludeVideo(videoId, title) {
    // Refresh CSRF token before operation
    if (!await refreshCSRFToken()) {
        alert('Erro: N√£o foi poss√≠vel validar a sess√£o. Por favor, recarregue a p√°gina.');
        return;
    }

    // Prompt for password
    const password = prompt(`Excluir v√≠deo "${title}"?\n\nIsso ir√° remover permanentemente:\n- V√≠deo\n- Transcri√ß√£o\n- Todos os dados relacionados\n\nDigite a senha de admin para confirmar:`);

    if (!password) {
        return; // User cancelled
    }

    try {
        const response = await fetch(`/api/videos/${videoId}/exclude`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': csrfToken
            },
            body: JSON.stringify({ password: password })
        });

        const data = await response.json();

        if (data.success) {
            alert(`V√≠deo exclu√≠do com sucesso!`);
            loadRecentVideos();
        } else {
            alert(`Erro ao excluir v√≠deo: ${data.detail || 'Erro desconhecido'}`);
        }
    } catch (error) {
        alert(`Erro ao excluir v√≠deo: ${error.message}`);
    }
}

// Cache for fetched transcripts
const transcriptCache = {};

function formatDateLabel(dateStr) {
    if (!dateStr) return 'N√£o definido';
    const [year, month, day] = dateStr.split('-');
    return `${month}/${day}/${year}`;
}

// Toggle transcript expansion
async function toggleTranscript(videoId, rowElement) {
    const expansionRow = document.getElementById(`transcript-${videoId}`);
    const videoRow = rowElement;
    const isExpanded = videoRow.classList.contains('expanded');

    if (isExpanded) {
        // Collapse
        videoRow.classList.remove('expanded');
        expansionRow.classList.remove('visible');
    } else {
        // Expand
        videoRow.classList.add('expanded');
        expansionRow.classList.add('visible');

        // Fetch transcript if not cached
        if (!transcriptCache[videoId]) {
            await fetchAndDisplayTranscript(videoId, expansionRow);
        }
    }
}

async function editSermonDateInline(videoId) {
    const display = document.getElementById(`sermon-date-display-${videoId}`);
    if (!display) return;

    const currentIso = display.dataset.iso || '';
    const newValue = prompt("Informe a data real do culto (YYYY-MM-DD). Deixe vazio para remover.", currentIso);

    if (newValue === null) {
        return;
    }

    const trimmed = newValue.trim();
    if (trimmed && !/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) {
        alert("Formato inv√°lido. Use YYYY-MM-DD.");
        return;
    }

    try {
        const response = await fetch(`/api/videos/${videoId}/sermon-date`, {
            method: 'PUT',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ sermon_actual_date: trimmed || null })
        });

        const data = await response.json();
        if (data.success) {
            display.dataset.iso = data.sermon_actual_date || '';
            display.textContent = formatDateLabel(data.sermon_actual_date);
            alert('Data do culto atualizada!');
        } else {
            alert(data.detail || 'Erro ao atualizar data do culto');
        }
    } catch (error) {
        alert(`Erro ao atualizar data do culto: ${error.message}`);
    }
}

// Fetch and display comprehensive sermon data via AJAX
async function fetchAndDisplayTranscript(videoId, expansionRow) {
    const loadingDiv = expansionRow.querySelector('.transcript-loading');
    const containerDiv = expansionRow.querySelector('.transcript-container');

    // Show loading indicator
    loadingDiv.style.display = 'block';
    containerDiv.style.display = 'none';

    try {
        const response = await fetch(`/api/videos/${videoId}/detailed-report`);
        const data = await response.json();

        if (data.success && data.report) {
            // Cache the report
            transcriptCache[videoId] = data;

            const report = data.report;

            // Build comprehensive sermon content HTML
            let contentHTML = '<div class="sermon-expansion-content">';

            // Sermon Start Time Banner
            // Informa√ß√µes Gerais (moved to top, with Temas integrated)
            if (report.statistics) {
                const stats = report.statistics;
                const sermonDateIso = data.video_info?.sermon_actual_date || '';
                const sermonDateDisplay = formatDateLabel(sermonDateIso);
                contentHTML += `
                    <div class="sermon-section">
                        <h3>üìä Informa√ß√µes Gerais</h3>
                        <div class="sermon-meta">
                            <div class="meta-card">
                                <strong>Dura√ß√£o</strong>
                                <span>${formatDuration(stats.duration_minutes * 60)}</span>
                            </div>
                            <div class="meta-card">
                                <strong>Palavras</strong>
                                <span>${stats.word_count.toLocaleString()}</span>
                            </div>
                            <div class="meta-card">
                                <strong>Pregador</strong>
                                <div>
                                    <!-- Display mode (default) -->
                                    <span id="speaker-display-${videoId}" style="display: inline;">
                                        ${report.speaker || data.video_info.speaker || 'N√£o identificado'}
                                    </span>
                                    <button onclick="toggleSpeakerEdit(${videoId})"
                                            id="speaker-edit-btn-${videoId}"
                                            style="margin-left: 0.5rem; padding: 0.2rem 0.5rem; font-size: 0.85rem; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                        ‚úèÔ∏è
                                    </button>

                                    <!-- Edit mode (hidden by default) -->
                                    <div id="speaker-edit-container-${videoId}" style="display: none; margin-top: 0.5rem;">
                                        <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                                            <!-- Input container (full width) -->
                                            <div style="width: 100%; position: relative;">
                                                <input type="text"
                                                       id="speaker-${videoId}"
                                                       value="${report.speaker || data.video_info.speaker || ''}"
                                                       style="width: 100%; height: 2.75rem; padding: 0.5rem; margin: 0; border: 2px solid #3498db; border-radius: 6px; background: #1e293b; color: white; font-size: 0.95rem; box-sizing: border-box;"
                                                       placeholder="Digite o nome do pregador..."
                                                       oninput="handleSpeakerInput(${videoId}, this.value)"
                                                       onfocus="handleSpeakerInput(${videoId}, this.value)">
                                                <div id="speaker-suggestions-${videoId}"
                                                     style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-radius: 4px; max-height: 200px; overflow-y: auto; z-index: 1000; display: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                                                </div>
                                            </div>

                                            <!-- Buttons row (centered below input) -->
                                            <div style="display: flex; gap: 0.5rem; justify-content: center;">
                                                <button onclick="saveSpeaker(${videoId})"
                                                        style="height: 2.75rem; padding: 0 1.25rem; font-size: 0.95rem; white-space: nowrap; display: flex; align-items: center; justify-content: center; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                                                    üíæ Salvar
                                                </button>
                                                <button onclick="cancelSpeakerEdit(${videoId})"
                                                        style="height: 2.75rem; padding: 0 1rem; font-size: 0.95rem; white-space: nowrap; display: flex; align-items: center; justify-content: center; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer;">
                                                    ‚ùå
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="meta-card">
                                <strong>Data do culto</strong>
                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                    <span id="sermon-date-display-${videoId}" data-iso="${sermonDateIso}">
                                        ${sermonDateDisplay}
                                    </span>
                                    <button onclick="editSermonDateInline(${videoId})"
                                            style="padding: 0.2rem 0.5rem; font-size: 0.85rem; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                        ‚úèÔ∏è
                                    </button>
                                </div>
                            </div>
                        </div>
                        ${(report.biblical_content?.key_passages || []).length > 0 ? `
                            <div style="margin-top: 1rem;">
                                <h4 style="font-size: 0.95rem; margin-bottom: 0.5rem;">üìñ Refer√™ncias B√≠blicas (${(report.biblical_content?.key_passages || []).length})</h4>
                                <div class="biblical-references">
                                    ${(report.biblical_content?.key_passages || []).slice(0, 10).map(p => `
                                        <span class="bible-ref bible-ref-${p.type}"
                                              title="${p.book} ${p.chapter}:${p.verse_start}${p.verse_end ? '-' + p.verse_end : ''} (${p.type === 'citation' ? 'Cita√ß√£o' : p.type === 'reading' ? 'Leitura' : 'Men√ß√£o'})">
                                            ${p.book} ${p.chapter}${p.verse_start ? ':' + p.verse_start : ''}${p.verse_end && p.verse_end !== p.verse_start ? '-' + p.verse_end : ''}
                                        </span>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // Suggested Title (AI-generated descriptive title)
            if (report.suggested_title) {
                contentHTML += `
                    <div class="sermon-section suggested-title-section">
                        <h3>
                            <span style="display: inline-flex; align-items: center; gap: 0.5rem;">
                                ü§ñ Titulo Sugerido por IA
                            </span>
                        </h3>
                        <p>${report.suggested_title}</p>
                    </div>
                `;
            }

            // AI Summary
            contentHTML += `
                <div class="sermon-section">
                    <h3>üìù Resumo do Serm√£o</h3>
                    <div class="sermon-summary">
                        ${report.ai_summary &&
                          !report.ai_summary.includes('429') &&
                          !report.ai_summary.includes('exceeded your current quota') &&
                          !report.ai_summary.includes('You exceeded') &&
                          !report.ai_summary.toLowerCase().includes('api.google.dev')
                          ? report.ai_summary.replace(/\n/g, '<br>')
                          : '<p class="no-data">Resumo temporariamente indispon√≠vel</p>'}
                    </div>
                </div>
            `;

            // Highlights
            if (report.highlights && report.highlights.length > 0) {
                contentHTML += `
                    <div class="sermon-section">
                        <h3>‚≠ê Destaques</h3>
                        ${report.highlights.map(h => `
                            <div class="highlight-item">
                                <h4>${h.title}</h4>
                                <p>${h.summary}</p>
                                ${h.timestamp ? `<div class="highlight-timestamp">‚è±Ô∏è ${formatSeconds(h.timestamp)}</div>` : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Discussion Questions
            if (report.discussion_questions && report.discussion_questions.length > 0) {
                const questionsId = `questions-${report.video_id}`;
                contentHTML += `
                    <div class="sermon-section">
                        <h3 onclick="toggleSection('${questionsId}')" style="cursor: pointer; user-select: none;">
                            <span id="${questionsId}-arrow" class="section-arrow">‚ñº</span> üí≠ Perguntas para Discuss√£o
                        </h3>
                        <div id="${questionsId}" class="collapsible-section">
                            ${report.discussion_questions.map((q, i) => `
                                <div class="question-item">
                                    <strong>${i + 1}.</strong> ${q.question}
                                    ${q.passage ? `<div style="margin-top: 0.5rem; color: #666; font-size: 0.9rem;">üìñ ${q.passage}</div>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            // Full Transcript (collapsible) - moved to bottom
            contentHTML += `
                <div class="sermon-section">
                    <h3 style="cursor: pointer; user-select: none;" onclick="toggleFullTranscript(${videoId})">
                        üìÑ Transcri√ß√£o Completa
                        <span id="transcript-arrow-${videoId}" style="font-size: 0.8em;">‚ñº</span>
                    </h3>
                    <div id="full-transcript-${videoId}" style="display: none; max-height: 400px; overflow-y: auto; padding: 1rem; background: var(--surface); color: var(--text); border-radius: 4px; line-height: 1.6; white-space: pre-wrap;">
                        <div class="transcript-loading" style="text-align: center; padding: 2rem;">
                            <div class="progress-indicator"></div>
                            Carregando transcri√ß√£o...
                        </div>
                    </div>
                </div>
            `;

            contentHTML += '</div>';
            containerDiv.innerHTML = contentHTML;
        } else {
            // No report available
            containerDiv.innerHTML = `
                <div class="no-data">
                    <p>${data.message || 'Relat√≥rio n√£o dispon√≠vel para este v√≠deo.'}</p>
                </div>
            `;
        }
    } catch (error) {
        // Error fetching report
        containerDiv.innerHTML = `
            <div class="no-data" style="color: #e74c3c;">
                <p>Erro ao carregar conte√∫do: ${error.message}</p>
            </div>
        `;
    } finally {
        // Hide loading, show content
        loadingDiv.style.display = 'none';
        containerDiv.style.display = 'block';
    }
}

// Helper function to format seconds to MM:SS
function formatSeconds(seconds) {
    if (!seconds) return '00:00';
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Initial load
loadRecentVideos();

// ============================================================================
// CHATBOT FUNCTIONALITY
// ============================================================================

// Generate unique session ID
let chatSessionId = generateSessionId();

function generateSessionId() {
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Toggle chatbot drawer visibility
function toggleChatDrawer() {
    const panel = document.getElementById('chatbotPanel');
    const backdrop = document.getElementById('chatBackdrop');
    const fab = document.getElementById('chatFAB');

    const isVisible = panel.classList.contains('visible');

    if (isVisible) {
        // Hide drawer - update right position based on current width
        const currentWidth = panel.offsetWidth;
        panel.style.right = -currentWidth + 'px';
        panel.classList.remove('visible');
        backdrop.classList.remove('visible');
        fab.style.display = 'flex';
    } else {
        // Show drawer
        panel.style.right = '0';
        panel.classList.add('visible');
        backdrop.classList.add('visible');
        fab.style.display = 'none';
    }
}

// Refresh chat - start new session
function refreshChat() {
    chatSessionId = generateSessionId();
    const messagesDiv = document.getElementById('chatMessages');
    messagesDiv.innerHTML = `
        <div class="chat-message assistant">
            <div class="chat-bubble">
                Ol√°! Sou seu assistente para explorar os serm√µes. Posso responder perguntas sobre qualquer prega√ß√£o, temas b√≠blicos ou conte√∫do espec√≠fico. Como posso ajudar?
            </div>
        </div>
    `;
}

// Chatbot resize functionality
(function initChatbotResize() {
    const panel = document.getElementById('chatbotPanel');
    const handle = document.getElementById('chatbotResizeHandle');

    if (!panel || !handle) return;

    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    // Minimum and maximum widths (matching CSS)
    const MIN_WIDTH = 300;
    const MAX_WIDTH = 800;

    // Load saved width from localStorage
    const savedWidth = localStorage.getItem('chatbotPanelWidth');
    if (savedWidth) {
        const width = parseInt(savedWidth, 10);
        if (width >= MIN_WIDTH && width <= MAX_WIDTH) {
            panel.style.width = width + 'px';
            // Update the hidden position to match new width
            updateHiddenPosition(width);
        }
    }

    function updateHiddenPosition(width) {
        // Only update if panel is not visible
        if (!panel.classList.contains('visible')) {
            panel.style.right = -width + 'px';
        }
    }

    // Mouse down on resize handle
    handle.addEventListener('mousedown', function(e) {
        // Only allow resize on desktop (screen width > 768px)
        if (window.innerWidth <= 768) return;

        isResizing = true;
        startX = e.clientX;
        startWidth = panel.offsetWidth;

        // Add resizing class to disable transitions
        panel.classList.add('resizing');
        handle.classList.add('active');

        // Prevent text selection during resize
        document.body.style.userSelect = 'none';
        document.body.style.cursor = 'ew-resize';

        e.preventDefault();
    });

    // Mouse move for resizing
    document.addEventListener('mousemove', function(e) {
        if (!isResizing) return;

        // Calculate new width (dragging left increases width)
        const deltaX = startX - e.clientX;
        let newWidth = startWidth + deltaX;

        // Clamp to min/max
        newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, newWidth));

        // Apply new width
        panel.style.width = newWidth + 'px';
    });

    // Mouse up to finish resizing
    document.addEventListener('mouseup', function(e) {
        if (!isResizing) return;

        isResizing = false;

        // Remove resizing class
        panel.classList.remove('resizing');
        handle.classList.remove('active');

        // Restore body styles
        document.body.style.userSelect = '';
        document.body.style.cursor = '';

        // Save width to localStorage
        const currentWidth = panel.offsetWidth;
        localStorage.setItem('chatbotPanelWidth', currentWidth);

        // Update hidden position for next time drawer is closed
        if (!panel.classList.contains('visible')) {
            updateHiddenPosition(currentWidth);
        }
    });

    // Handle window resize to reset if screen becomes mobile
    window.addEventListener('resize', function() {
        if (window.innerWidth <= 768) {
            // Reset to default mobile behavior
            panel.style.width = '';
        } else {
            // Restore saved width on desktop
            const savedWidth = localStorage.getItem('chatbotPanelWidth');
            if (savedWidth) {
                const width = parseInt(savedWidth, 10);
                if (width >= MIN_WIDTH && width <= MAX_WIDTH) {
                    panel.style.width = width + 'px';
                }
            }
        }
    });

    // Also handle touch events for better tablet support
    handle.addEventListener('touchstart', function(e) {
        if (window.innerWidth <= 768) return;

        isResizing = true;
        startX = e.touches[0].clientX;
        startWidth = panel.offsetWidth;

        panel.classList.add('resizing');
        handle.classList.add('active');

        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchmove', function(e) {
        if (!isResizing) return;

        const deltaX = startX - e.touches[0].clientX;
        let newWidth = startWidth + deltaX;
        newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, newWidth));
        panel.style.width = newWidth + 'px';
    }, { passive: true });

    document.addEventListener('touchend', function(e) {
        if (!isResizing) return;

        isResizing = false;
        panel.classList.remove('resizing');
        handle.classList.remove('active');

        const currentWidth = panel.offsetWidth;
        localStorage.setItem('chatbotPanelWidth', currentWidth);
    });
})();

// Send chat message
async function sendChatMessage() {
    // Refresh CSRF token before operation
    if (!await refreshCSRFToken()) {
        alert('Erro: N√£o foi poss√≠vel validar a sess√£o. Por favor, recarregue a p√°gina.');
        return;
    }

    const input = document.getElementById('chatInput');
    const sendBtn = document.getElementById('chatSendBtn');
    const messagesDiv = document.getElementById('chatMessages');

    const message = input.value.trim();

    if (!message) return;

    // Disable input while processing
    input.disabled = true;
    sendBtn.disabled = true;

    // Add user message to chat
    const userMessageDiv = document.createElement('div');
    userMessageDiv.className = 'chat-message user';
    userMessageDiv.innerHTML = `
        <div class="chat-bubble">${escapeHtml(message)}</div>
    `;
    messagesDiv.appendChild(userMessageDiv);

    // Clear input
    input.value = '';

    // Scroll to bottom
    messagesDiv.scrollTop = messagesDiv.scrollHeight;

    // Add loading indicator
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'chat-loading';
    loadingDiv.innerHTML = 'ü§î Pensando...';
    messagesDiv.appendChild(loadingDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;

    try {
        const response = await fetch(`/api/channels/${CHANNEL_ID}/chat`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': csrfToken
            },
            body: JSON.stringify({
                message: message,
                session_id: chatSessionId
            })
        });

        const data = await response.json();

        // Remove loading indicator
        messagesDiv.removeChild(loadingDiv);

        if (data.success) {
            // Add assistant response
            const assistantMessageDiv = document.createElement('div');
            assistantMessageDiv.className = 'chat-message assistant';

            let citationsHtml = '';
            if (data.cited_videos && data.cited_videos.length > 0) {
                citationsHtml = '<div class="chat-citations">üìö Fontes: ';
                data.cited_videos.forEach((video) => {
                    citationsHtml += `<span class="chat-citation">${video.video_title}</span>`;
                });
                citationsHtml += '</div>';
            }

            assistantMessageDiv.innerHTML = `
                <div class="chat-bubble">
                    ${formatChatResponse(data.response)}
                </div>
                ${citationsHtml}
            `;
            messagesDiv.appendChild(assistantMessageDiv);

            // Update session ID if provided
            if (data.session_id) {
                chatSessionId = data.session_id;
            }
        } else {
            // Error response
            const errorDiv = document.createElement('div');
            errorDiv.className = 'chat-message assistant';
            errorDiv.innerHTML = `
                <div class="chat-bubble" style="background: #fee; border-color: #e74c3c; color: #c0392b;">
                    Desculpe, ocorreu um erro. Por favor, tente novamente.
                </div>
            `;
            messagesDiv.appendChild(errorDiv);
        }

    } catch (error) {
        console.error('Chat error:', error);

        // Remove loading indicator
        if (messagesDiv.contains(loadingDiv)) {
            messagesDiv.removeChild(loadingDiv);
        }

        // Show error
        const errorDiv = document.createElement('div');
        errorDiv.className = 'chat-message assistant';
        errorDiv.innerHTML = `
            <div class="chat-bubble" style="background: #fee; border-color: #e74c3c; color: #c0392b;">
                Erro de conex√£o. Por favor, tente novamente.
            </div>
        `;
        messagesDiv.appendChild(errorDiv);
    } finally {
        // Re-enable input
        input.disabled = false;
        sendBtn.disabled = false;
        input.focus();

        // Scroll to bottom
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
}

// Format chat response (convert newlines to <br>)
function formatChatResponse(text) {
    return escapeHtml(text).replace(/\n/g, '<br>');
}

// Escape HTML to prevent XSS
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Toggle full transcript display
async function toggleFullTranscript(videoId) {
    const transcriptDiv = document.getElementById(`full-transcript-${videoId}`);
    const arrow = document.getElementById(`transcript-arrow-${videoId}`);

    if (transcriptDiv.style.display === 'none') {
        // Expand and load transcript if not already loaded
        transcriptDiv.style.display = 'block';
        arrow.textContent = '‚ñ≤';

        // Check if transcript is already loaded
        const loadingDiv = transcriptDiv.querySelector('.transcript-loading');
        if (loadingDiv) {
            // Fetch transcript
            try {
                const response = await fetch(`/api/videos/${videoId}/transcript`);
                const data = await response.json();

                if (data.success && data.transcript_text) {
                    // Split transcript into paragraphs
                    let paragraphs = data.transcript_text.split('\n\n').filter(p => p.trim());

                    // If only one paragraph (continuous text), split intelligently at sentence boundaries
                    if (paragraphs.length === 1) {
                        const text = paragraphs[0];
                        paragraphs = [];
                        const sentences = text.split(/(?<=[.!?])\s+/);
                        let currentParagraph = '';

                        for (const sentence of sentences) {
                            if (currentParagraph.length + sentence.length > 600) {
                                if (currentParagraph) paragraphs.push(currentParagraph.trim());
                                currentParagraph = sentence;
                            } else {
                                currentParagraph += (currentParagraph ? ' ' : '') + sentence;
                            }
                        }
                        if (currentParagraph) paragraphs.push(currentParagraph.trim());
                    }

                    const formattedTranscript = paragraphs.map(p => `<p style="margin-bottom: 1rem; color: var(--text);">${escapeHtml(p.trim())}</p>`).join('');
                    transcriptDiv.innerHTML = `<div style="padding: 1rem; background: var(--surface); color: var(--text); border-radius: 4px; line-height: 1.6;">${formattedTranscript}</div>`;
                } else {
                    transcriptDiv.innerHTML = `<p style="text-align: center; color: #9CA3AF;">Transcri√ß√£o n√£o dispon√≠vel</p>`;
                }
            } catch (error) {
                console.error('Error loading transcript:', error);
                transcriptDiv.innerHTML = `<p style="text-align: center; color: #B91C1C;">Erro ao carregar transcri√ß√£o</p>`;
            }
        }
    } else {
        // Collapse
        transcriptDiv.style.display = 'none';
        arrow.textContent = '‚ñº';
    }
}

// Toggle speaker edit mode
function toggleSpeakerEdit(videoId) {
    const displaySpan = document.getElementById(`speaker-display-${videoId}`);
    const editBtn = document.getElementById(`speaker-edit-btn-${videoId}`);
    const editContainer = document.getElementById(`speaker-edit-container-${videoId}`);
    const input = document.getElementById(`speaker-${videoId}`);

    // Toggle visibility
    if (editContainer.style.display === 'none') {
        // Enter edit mode
        displaySpan.style.display = 'none';
        editBtn.style.display = 'none';
        editContainer.style.display = 'block';

        // Store original value for cancel (before clearing)
        input.dataset.originalValue = input.value;

        // Clear "Desconhecido" or similar placeholder values
        const clearValues = ['Desconhecido', 'desconhecido', 'N√£o identificado', 'n√£o identificado', 'Desconhec'];
        if (clearValues.some(val => input.value.includes(val))) {
            input.value = '';
        }

        // Focus input and trigger autocomplete with empty value to show popular speakers
        setTimeout(() => {
            input.focus();
            handleSpeakerInput(videoId, '');
        }, 50);
    } else {
        // Exit edit mode (should not be called directly, use save/cancel)
        displaySpan.style.display = 'inline';
        editBtn.style.display = 'inline-block';
        editContainer.style.display = 'none';
    }
}

// Save speaker name
async function saveSpeaker(videoId) {
    // Refresh CSRF token before operation
    if (!await refreshCSRFToken()) {
        alert('Erro: N√£o foi poss√≠vel validar a sess√£o. Por favor, recarregue a p√°gina.');
        return;
    }

    const input = document.getElementById(`speaker-${videoId}`);
    const speaker = input.value.trim();

    if (!speaker) {
        alert('Por favor, insira o nome do pregador');
        return;
    }

    // Check if CSRF token exists
    if (typeof csrfToken === 'undefined') {
        console.error('CSRF token not found');
        alert('Erro de autentica√ß√£o. Por favor, recarregue a p√°gina.');
        return;
    }

    try {
        const response = await fetch(`/api/videos/${videoId}/speaker`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': csrfToken
            },
            credentials: 'include',
            body: JSON.stringify({ speaker: speaker })
        });

        // Check response status before parsing JSON
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Server error:', response.status, errorText);

            // Handle authentication error specifically
            if (response.status === 401) {
                alert('Sess√£o expirada. Por favor, fa√ßa login novamente.');
                window.location.href = '/login';
                return;
            }

            alert(`Erro ao salvar pregador (${response.status}). Por favor, tente novamente.`);
            return;
        }

        const data = await response.json();

        if (data.success) {
            // Update display
            const displaySpan = document.getElementById(`speaker-display-${videoId}`);
            const editBtn = document.getElementById(`speaker-edit-btn-${videoId}`);
            const editContainer = document.getElementById(`speaker-edit-container-${videoId}`);

            if (displaySpan && editContainer) {
                displaySpan.textContent = speaker;
                displaySpan.style.display = 'inline';
                editBtn.style.display = 'inline-block';
                editContainer.style.display = 'none';
            }

            // Show success message briefly
            const statusSpan = document.createElement('span');
            statusSpan.textContent = ' ‚úÖ Salvo!';
            statusSpan.style.color = '#10b981';
            statusSpan.style.marginLeft = '0.5rem';
            displaySpan.parentNode.appendChild(statusSpan);
            setTimeout(() => statusSpan.remove(), 2000);
        } else {
            alert('Erro ao salvar pregador: ' + (data.detail || 'Erro desconhecido'));
        }
    } catch (error) {
        console.error('Error saving speaker:', error);
        alert('Erro ao salvar pregador: ' + error.message + '. Verifique sua conex√£o.');
    }
}

// Cancel speaker edit
function cancelSpeakerEdit(videoId) {
    const displaySpan = document.getElementById(`speaker-display-${videoId}`);
    const editBtn = document.getElementById(`speaker-edit-btn-${videoId}`);
    const editContainer = document.getElementById(`speaker-edit-container-${videoId}`);
    const input = document.getElementById(`speaker-${videoId}`);

    // Restore original value
    if (input.dataset.originalValue !== undefined) {
        input.value = input.dataset.originalValue;
    }

    // Return to display mode
    displaySpan.style.display = 'inline';
    editBtn.style.display = 'inline-block';
    editContainer.style.display = 'none';

    // Hide suggestions
    const suggestions = document.getElementById(`speaker-suggestions-${videoId}`);
    if (suggestions) {
        suggestions.style.display = 'none';
    }
}

// Speaker autocomplete with debouncing
let speakerDebounceTimers = {};

async function handleSpeakerInput(videoId, value) {
    const suggestionsDiv = document.getElementById(`speaker-suggestions-${videoId}`);

    // Clear previous timer
    if (speakerDebounceTimers[videoId]) {
        clearTimeout(speakerDebounceTimers[videoId]);
    }

    const trimmedValue = (value || '').trim();

    // Allow 0 characters (popular speakers) and 1+ characters (search)
    // No minimum length restriction - let the API handle filtering

    // Optimized debounce: 0ms for empty (popular immediately), 150ms for 1 char, 300ms for 2+
    const debounceDelay = trimmedValue.length === 0 ? 0 : (trimmedValue.length === 1 ? 150 : 300);

    speakerDebounceTimers[videoId] = setTimeout(async () => {
        try {
            // Empty query gets popular speakers, any typed query gets filtered results
            const query = trimmedValue.length >= 1 ? encodeURIComponent(trimmedValue) : '';
            const response = await fetch(`/api/speakers/autocomplete?q=${query}&limit=5`);
            const data = await response.json();

            if (data.suggestions && data.suggestions.length > 0) {
                suggestionsDiv.innerHTML = data.suggestions.map(s => `
                    <div onclick="selectSpeaker(${videoId}, '${s.name.replace(/'/g, "\\'")}')"
                         style="padding: 0.5rem; cursor: pointer; border-bottom: 1px solid var(--border); transition: background 0.2s; color: var(--text);"
                         onmouseover="this.style.background='var(--muted)'"
                         onmouseout="this.style.background='var(--surface)'">
                        ${s.name} <small style="color: var(--text-muted);">(${s.video_count} v√≠deos)</small>
                    </div>
                `).join('');
                suggestionsDiv.style.display = 'block';
            } else {
                suggestionsDiv.style.display = 'none';
            }
        } catch (error) {
            console.error('Error fetching speaker suggestions:', error);
            suggestionsDiv.style.display = 'none';
        }
    }, debounceDelay);
}

function selectSpeaker(videoId, name) {
    const input = document.getElementById(`speaker-${videoId}`);
    const suggestionsDiv = document.getElementById(`speaker-suggestions-${videoId}`);

    input.value = name;
    suggestionsDiv.style.display = 'none';
}

// Toggle collapsible sections (e.g., Discussion Questions)
function toggleSection(sectionId) {
    const section = document.getElementById(sectionId);
    const arrow = document.getElementById(`${sectionId}-arrow`);

    if (!section || !arrow) return;

    if (section.style.display === 'none') {
        section.style.display = 'block';
        arrow.textContent = '‚ñº';
    } else {
        section.style.display = 'none';
        arrow.textContent = '‚ñ∂';
    }
}

// Hide suggestions when clicking outside
document.addEventListener('click', function(e) {
    if (!e.target.closest('[id^="speaker-"]')) {
        document.querySelectorAll('[id^="speaker-suggestions-"]').forEach(div => {
            div.style.display = 'none';
        });
    }
});

// Auto-expand video if coming from "Ver" button (?expand=video_id)
document.addEventListener('DOMContentLoaded', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const expandVideoId = urlParams.get('expand');

    if (expandVideoId) {
        // Wait for videos to load, then expand the specified video
        setTimeout(() => {
            const videoRow = document.querySelector(`[data-video-id="${expandVideoId}"]`);
            if (videoRow) {
                toggleTranscript(parseInt(expandVideoId));
                // Scroll to the video
                videoRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 1000);

        // Clean URL (remove expand parameter)
        window.history.replaceState({}, document.title, window.location.pathname);
    }
});
</script>
{% endblock %}
